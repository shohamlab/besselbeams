# -*- coding: utf-8 -*-
"""
Created on Sun Nov 20 11:30:59 2022

Implementation of
[1] Z. Zhai, Z. Cheng, Q. Lv, and X. Wang, “Tunable Axicons Generated by Spatial Light Modulator with High-Level Phase Computer-Generated Holograms,” Applied Sciences, vol. 10, no. 15, Art. no. 15, Jan. 2020, doi: 10.3390/app10155127.

@author: sstucker
"""
import random
from numba import jit
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

import numpy as np
from scipy.special import j0 as J0
from scipy.constants import pi as PI

from PIL import Image

font = {'family' : 'Arial',
        'weight' : 'normal',
        'size'   : 12
        }
matplotlib.rc('font', **font)

def axicon_mask(dimensions: np.ndarray, period: int) -> np.ndarray:
    mask = np.zeros(dimensions).astype(np.uint16)
    _axicon_mask(mask, period)
    mask = ((mask / np.max(mask)) * 255).astype(np.uint16)
    return mask

@jit
def _axicon_mask(mask: np.ndarray, period: int):
    holo_x: int = mask.shape[0] // 2
    holo_y: int = mask.shape[1] // 2
    for i, x in enumerate(np.linspace(-holo_x, holo_x, mask.shape[0]).astype(np.float32)):
        for j, y in enumerate(np.linspace(-holo_y, holo_y, mask.shape[1]).astype(np.float32)):
            mask[i, j] = period - int(np.sqrt(x**2 + y**2)) % period


@jit
def _bessel_field(k, A, n, h, d, w, N, z, r, lam, bessel_term) -> np.complex64:
    S = 0
    for m in range(N - 1):
        S += np.exp(1j * (k * (((n - 1)**2 * h**2 * z) / (2 * d**2) + (n - 1)*m*h) + PI / 4 ))
    return \
        A*k*(n - 1)*np.sqrt(lam*z)*(h / d)*bessel_term * \
        np.exp(-1 * (((n - 1)*z*h) / (w * d))**2) * np.exp(1j*k*(z + r**2 / (2 * z))) * \
        S


# %%


"""
TODO PhaseMask and Axicon both produce BesselField. There is one function, 
visualize, which takes both of them and produces a figure.
"""

class BesselField():
    
    def __init__(self, field: np.ndarray, wavelength: float, beam_waist: float, simulation_length_z: float, simulation_radius_r: float):
        self._field = field
        self.wavelength = wavelength
        self.beam_waist = beam_waist
        self.max_z = simulation_length_z
        self.max_r = simulation_radius_r
        
        self.axial_max_profile = np.max(2 * np.abs(field)**2, axis=-1)  # Maximum intensity profile
        self.axial_max_index = np.argmax(self.axial_max_profile)
        self.axial_max = (self.axial_max_index / self._field.shape[0]) * simulation_length_z  # mm
    
    @property
    def field(self):
        return self._field
    
    def shape(self):
        return self._field.shape

    def __add__(self, field):
        if isinstance(field, BesselField):
            if not any([a == b for a, b in zip(
                    (self.field.shape, self.wavelength, self.beam_waist, self.max_z, self.max_r),
                    (field.field.shape, field.wavelength, field.beam_waist, field.max_z, field.max_r)
            )]):
                raise ValueError('The fields are not equivalent')
            return BesselField(self.field + field.field, self.wavelength, self.beam_waist, self.max_z, self.max_r)
        else:
            raise TypeError("Cannot interfere field with '{}'!".format(type(field).__name__))
        

class BesselSource():
    
    def generate_field(self, wavelength, beam_waist, simulation_length_z, simulation_radius_r, nz=512, nr=128) -> BesselField:
        
        # ZX-cross-section generation
        xs = np.empty([nz, 2 * nr + 1], dtype=np.complex64)
        for i, z in enumerate(np.linspace(0, simulation_length_z, nz)):
            for j, r in enumerate(np.linspace(-simulation_radius_r, simulation_radius_r, 2 * nr + 1)):
                xs[i, j] = self.bessel(z, r, wavelength, beam_waist)
        return BesselField(xs, wavelength, beam_waist, simulation_length_z, simulation_radius_r)
    
    def bessel(self, z: float, r: float, wavelength: float, beam_waist: float) -> float:
        raise NotImplementedError()


class PhaseMask(BesselSource):
    
    def __init__(self, dimensions, pixel_size, phase_stroke, pixel_period):
        if pixel_period < 2:
            raise ValueError('Phase mask for period < 1 cannot be created')
        if type(pixel_period) is not int:
            raise TypeError('Pixel period must be a positive integer')
        self.dimensions = dimensions
        self.pixel_size = pixel_size
        self.phase_stroke = phase_stroke
        self.pixel_period = pixel_period
        self._mask = axicon_mask(dimensions, pixel_period)
        
    @property
    def mask(self):
        return self._mask    
    
    def bessel(self, z: float, r: float, wavelength: float, beam_waist: float) -> float:
        k = (2 * PI) / wavelength
        n = self.phase_stroke  # Index of refraction of SLM
        h = self.phase_stroke * wavelength  # Height of ramp
        d = self.pixel_period * self.pixel_size  # Width of ramp
        intensity = 1.0
        return 2 * intensity * PI * k * z * (h / d)**2 * (n - 1)**2 * np.exp(-2 * (((n - 1) * z * h) / (beam_waist * d))**2 ) * J0(k * (n - 1) * r * (h / d))
    
    # def bessel(self, z: float, r: float, wavelength: float, beam_waist: float) -> float:
    #     k = (2 * PI) / wavelength
    #     A = 1.0  # Amplitude                 
    #     n = self.phase_stroke  # Index of refraction of SLM
    #     h = self.phase_stroke * wavelength  # Height of ramp (mm)
    #     d = self.pixel_period * self.pixel_size  # Width of ramp (mm)
    #     w = beam_waist  # mm
    #     lam = wavelength  # mm
    #     N = round(np.min(self.dimensions) / (2 * d))  # Number of rings in the pattern
    #     # Preventing underflow
    #     z = z + 1E-16
    #     r = r + 1E-16
    #     j0_term = J0((k*(n - 1)*h*r) / d)  # Pass in result of Bessel function. TODO implement bessel fn
    #     return _bessel_field(k, A, n, h, d, w, N, z, r, lam, j0_term)    
    
    def add_uniform_random_sample(self, mask):
        if not isinstance(mask, PhaseMask) or not self._mask.shape == mask._mask.shape:
            raise ValueError("'mask' must be a PhaseMask instance with the same shape.")
        mask1 = self._mask.copy()
        mask2 = mask._mask
        for i in random.sample(range(mask1.size), mask1.size // 2):
            mask1.flat[i] = mask2.flat[i]
        return mask1  # TODO make return a PhaseMask instance
    
    def add_radial_sections(self, mask, sections=128):
        if not isinstance(mask, PhaseMask) or not self._mask.shape == mask._mask.shape:
            raise ValueError("'mask' must be a PhaseMask instance with the same shape.")
        mask1 = self._mask.copy()
        mask2 = mask._mask
        θs = np.linspace(0, 2 * np.pi, sections + 1)[:-1]
        dθ = θs[1] - θs[0]
        theta_bounds = []
        for θ in θs[::2]:
            theta_bounds.append((θ, θ + dθ))
        for i, x in enumerate(np.arange(mask1.shape[0]) - mask1.shape[0] // 2):
            for j, y in enumerate(np.arange(mask2.shape[1]) - mask2.shape[1] // 2):
                θ = np.arctan2(-x, -y) + np.pi
                for bounds in theta_bounds:
                    if θ >= bounds[0] and θ < bounds[1]:
                        mask1[i, j] = mask2[i, j]
        return mask1  # TODO make return a PhaseMask instance
    
    def gridify(self, m, n):
        # Reject uneven divisions of the array. TODO allow arbitrary divisions
        if self._mask.shape[0] % m != 0 or self._mask.shape[1] % n != 0:
            raise ValueError('PhaseMask with shape {} cannot be evenly divided into ({}, {}) sections'.format(self._mask.shape, m, n))
        section_shape = (self._mask.shape[0] / m, self._mask.shape[1] / n)
        # Deal with uneven section dimensions
        if section_shape[0] % 2 == 0:
            section_widths = np.ones(2) * section_shape[0] // 2
        else:
            section_widths = np.array([section_shape[0] // 2, section_shape[0] // 2 + 1])
        if section_shape[1] % 2 == 0:
            section_heights = np.ones(2) * section_shape[1] // 2
        else:
            section_widths = np.array([section_shape[1] // 2, section_shape[0] // 2 + 1])
        section_height = section_shape[1] / 2
        subsection = self._mask[
            int(self._mask.shape[0] // 2 - section_widths[0]):int(self._mask.shape[0] // 2 + section_widths[1]),
            int(self._mask.shape[1] // 2 - section_heights[0]):int(self._mask.shape[1] // 2 + section_heights[1])
        ]
        return np.tile(subsection, (m, n))
    
    def imshow(self):
        fig = plt.figure('PhaseMask imshow')
        ax = fig.subplot(1, 1, 1)
        fig.set_facecolor('black')
        ax.imshow(np.rot90(self._mask), cmap='Greys_r')
    
    def export(self, filename: str):
        img = self._mask
        bmp = Image.fromarray(np.rot90(img)).convert('RGB')
        bmp.save(filename.split('.')[0] + '.bmp')


class Axicon(BesselSource):
    
    def __init__(self, angle, radius, index_of_refraction):
        super().__init__()
        self.angle = angle
        self.diameter = 2 * radius
        self.n = index_of_refraction
    
    def bessel(self, z: float, r: float, wavelength: float, beam_waist: float):
        """Return intensity of the bessel field at position (z, r) along the optical axis following the axicon. See [1] Equation 2."""
        k = (2 * PI) / wavelength
        theta = self.angle  # Axicon base angle
        n = self.n  # Axicon index of refraction
        intensity = 1.0
        return 2*PI*k * np.tan(theta)**2 * (n - 1)**2 * z * intensity * np.exp(-2 * ((n - 1) * z * np.tan(theta) / beam_waist)**2) * J0(k * (n - 1) * r * np.tan(theta))**2
    
    def get_equivalent_mask(self, dimensions, wavelength, pixel_size, phase_stroke) -> PhaseMask:
        # Phase stroke of axicon equal to ([1] Equation 10.)
        axicon_h = wavelength / (self.n - 1)
        # Real phase stroke from SLM specs
        slm_h = wavelength * phase_stroke
        # Multiply by corrective phase stroke ratio
        px_per_ring = (slm_h / axicon_h) * (wavelength * phase_stroke) / (self.angle * pixel_size)
        px_per_ring = round(px_per_ring)
        return PhaseMask(dimensions, pixel_size, phase_stroke, px_per_ring)
    

def visualize(field: BesselField, source: BesselSource, ray_alpha=0.15, number_of_rays=14, aspect=5):
    fig, ax = plt.subplot_mosaic(
        [['upper left', 'upper middle', 'upper right'], ['bottom', 'bottom', 'bottom']],
        figsize=(17, 6),
    )
    fig.set_facecolor('black')
    
    # zx cross-section
    ax['bottom'].imshow(np.rot90(np.abs(field.field)**2), cmap='Greys_r', extent=(0, field.max_z, -field.max_r, field.max_r))
    ax['bottom'].set_facecolor('black')
    ax['bottom'].set_xlabel('z (mm)', color='white')
    ax['bottom'].tick_params(axis='x', colors='white')
    ax['bottom'].set_xlabel('mm', color='white')
    ax['bottom'].set_aspect(aspect)
    
    # Maximum intensity Z profile
    ax['upper middle'].set_facecolor('black')
    ax['upper middle'].plot(np.linspace(0, field.max_z, field.field.shape[0]), field.axial_max_profile, color='white', linewidth=1)
    ax['upper middle'].tick_params(axis='x', colors='white')
    ax['upper middle'].tick_params(axis='y', colors='white')
    ax['upper middle'].set_xlabel('mm', color='white')
    ax['upper middle'].set_ylabel('ADU', color='white')
    ax['upper middle'].set_yticks([])
    
    
    if isinstance(source, Axicon):

        axicon_radius = source.diameter / 2
        axicon_peak = axicon_radius * np.tan(source.angle)
        axicon_thickness = axicon_peak * 10
        
        ax['bottom'].set_xlim(-axicon_thickness, field.max_z)
        ax['bottom'].set_ylim(-axicon_radius, axicon_radius)
        
        # Rays
        for r0 in np.linspace(0, field.beam_waist / 2, number_of_rays):
            y1 = -axicon_peak + (axicon_radius - r0) * axicon_peak / axicon_radius
            ax['bottom'].plot([-axicon_thickness, y1], [r0, r0], '-y', linewidth=0.5, alpha=ray_alpha)
            ax['bottom'].plot([-axicon_thickness, y1], [-r0, -r0], '-y', linewidth=0.5, alpha=ray_alpha)
            theta_i = source.angle
            theta_o = np.arcsin(np.sin(theta_i) / source.n) - source.angle
            y2 = r0 + field.max_z * np.tan(theta_o)
            ax['bottom'].plot([y1, field.max_z], [r0, y2], '-y', linewidth=0.5, alpha=ray_alpha)
            ax['bottom'].plot([y1, field.max_z], [-r0, -y2], '-y', linewidth=0.5, alpha=ray_alpha)
        
        # Axicon glass
        a = np.transpose(np.array([
            [0, -axicon_peak, -axicon_thickness, -axicon_thickness, -axicon_peak],
            [0, axicon_radius, axicon_radius, -axicon_radius, -axicon_radius]])
        )
        glass = Polygon(a, fill=True, edgecolor=None, closed=True, facecolor='white', alpha=0.3)
        ax['bottom'].add_patch(glass)
        
        ax['upper left'].set_facecolor('black')

        # Text
        ax['bottom'].text(0, axicon_radius * 3.6, 'Axicon angle: {}°\nMaximum intensity at {} mm'.format(str(source.angle * 180 / PI)[0:6], str(field.axial_max)[0:6]), color='white')
        
    elif isinstance(source, PhaseMask):
        
        # Plot phase mask
        ax['upper left'].imshow(np.rot90(source.mask), cmap='Greys_r')
        
        # Set beam profile limits
        ax['bottom'].set_ylim(-field.max_r, field.max_r)
        
        # Text
        ax['bottom'].text(0, field.max_r * 18, 'SLM period: {} px ({} µm)\nMaximum intensity at {} mm'.format(str(source.pixel_period)[0:6], str(source.pixel_period * source.pixel_size * 1000)[0:6], str(field.axial_max)[0:6]), color='white')
    
    # xy cross-section
    z_disp = field.axial_max
    xs_z = np.empty([2 * field.field.shape[1] + 1, 2 * field.field.shape[1] + 1], dtype=np.complex64)
    for i, x in enumerate(np.linspace(-field.max_r, field.max_r, 2 * field.field.shape[1] + 1)):
        for j, y in enumerate(np.linspace(-field.max_r, field.max_r, 2 * field.field.shape[1] + 1)):
            r = np.linalg.norm([x, y])
            xs_z[i, j] = source.bessel(z_disp, r, field.wavelength, field.beam_waist)
    im = ax['upper right'].imshow(np.abs(xs_z)**2, cmap='Greys_r', extent=(-field.max_r * 1000, field.max_r * 1000, -field.max_r * 1000, field.max_r * 1000))
    ax['upper right'].tick_params(axis='x', colors='white')
    ax['upper right'].tick_params(axis='y', colors='white')
    ax['upper right'].set_xlabel('um', color='white')
    ax['upper right'].set_ylabel('um', color='white')


# %% Demo

if __name__ == "__main__":
    
    AXICON_ANGLE = 1.0 * PI / 180  # rad
    AXICON_RADIUS = 12.7 / 2  # mm
    AXICON_INDEX = 1.51637
    WAVELENGTH = 1040 * 10**-6  # mm
    BEAM_WAIST = 6  # mm
    SLM_DIM = [1920, 1152]  # px
    SLM_PHASE_STROKE = 1.4  # TODO upload Meadowlark LUT
    SLM_PIXEL_SIZE = 9.2 * 10**-3  # mm
    
    for angle_rad in np.linspace(0.0001, 0.0064, 128):
            ax = Axicon(angle_rad, AXICON_RADIUS, AXICON_INDEX)
            mask = ax.get_equivalent_mask(SLM_DIM, WAVELENGTH, SLM_PIXEL_SIZE, SLM_PHASE_STROKE)
            print('Creating mask with period', mask.pixel_period, 'corresponding to angle', angle_rad  * 1000, 'mrad')
            mask = PhaseMask(SLM_DIM, SLM_PIXEL_SIZE, SLM_PHASE_STROKE, int(mask.pixel_period))
            mask.export('R:\\shohas01lab\\shohas01labspace\\Stephen\\bessel_phase_masks_from_raytrace\\' + '1920_1152_N' + str(mask.pixel_period).zfill(3))
    
    # mask1 = PhaseMask(SLM_DIM, SLM_PIXEL_SIZE, SLM_PHASE_STROKE, 60)
    # for n in np.arange(1, 24):
    #     for m in np.arange(1, 24):
    #         try:
    #             img = mask1.gridify(n, m)
    #             bmp = Image.fromarray(np.rot90(img)).convert('RGB')
    #             bmp.save('R:\\shohas01lab\\shohas01labspace\\Stephen\\bessel_grid_phase_masks\\1920_1152_1D_grid_m' + str(n).zfill(3) + '_n' + str(m).zfill(3) + '.bmp')
    #         except:
    #             continue
            
    # for n in np.arange(15, 40).astype(int):
    #     print('Creating mask with period', n + 1)
    #     mask2 = PhaseMask(SLM_DIM, SLM_PIXEL_SIZE, SLM_PHASE_STROKE, int(n + 1))
    #     mask3 = mask1.add_uniform_random_sample(mask2)
    #     print(np.max(mask3), np.min(mask3))
    #     img = mask3
    #     bmp = Image.fromarray(np.rot90(img)).convert('RGB')
    #     bmp.save('R:\\shohas01lab\\shohas01labspace\\Stephen\\double_bessel_phase_masks\\' + '1920_1152_N13_N' + str(n + 1).zfill(3) + '_rand.bmp')
    # plt.imshow(np.rot90(img), cmap='gray_r')
    
    # %%
    # mask.export('R:\\shohas01lab\\shohas01labspace\\Stephen\\bessel_phase_masks\\' + '1920_1152_N' + str(n + 1).zfill(3))
    
    # for n in np.arange(2, 200).astype(int):
    #     print('Creating mask with period', n + 1)
    #     mask = PhaseMask(SLM_DIM, SLM_PIXEL_SIZE, SLM_PHASE_STROKE, int(n + 1))
    #     mask.export('R:\\shohas01lab\\shohas01labspace\\Stephen\\bessel_phase_masks\\' + '1920_1152_N' + str(n + 1).zfill(3))



